---
import { getTranslator } from '@gudupao/astro-i18n';
import logo from '../assets/home/logo.png';
import background from '../assets/home/background.png';
import heroImage from '../assets/home/hero.png';
const lang = Astro.params.lang || 'en';
const t = getTranslator(lang);
---

<div id="welcome-wrapper">
	<div id="container">
		<img id="background-image" src={background.src} alt="" draggable="false" />
		<!-- 鼠标光晕层 -->
		<div id="mouse-glow"></div>
		<main>
			<section id="hero">
				<div id="hero-image-wrapper">
					<svg id="hero-border-svg" width="100%" height="100%">
						<rect id="hero-border-rect" x="0" y="0" width="100%" height="100%" rx="24" ry="24"></rect>
					</svg>
					<canvas id="nano-canvas"></canvas>
					<img id="hero-img-element" src={heroImage.src} alt="Hero" draggable="false" crossorigin="anonymous" />
				</div>
				<section id="links">
					<a class="button glass-button" href={`/${lang || 'en'}/explore`}>
						<span class="button-content">{t('welcome.explore')}</span>
						<div class="button-glow"></div>
					</a>
				</section>
			</section>
		</main>
	</div>
</div>

<style>
	#welcome-wrapper {
		position: relative;
		height: 100vh;
		overflow: hidden;
		background: #000;
	}

	#background-image {
		position: fixed;
		top: 0;
		left: 0;
		width: 100%;
		height: 100vh;
		object-fit: cover;
		z-index: -1;
		user-select: none;
		pointer-events: none;
	}

	#container {
		font-family: Inter, Roboto, 'Helvetica Neue', 'Arial Nova', 'Nimbus Sans', Arial, sans-serif;
		height: 100%;
		position: absolute;
		top: 0;
		left: 0;
		width: 100%;
		perspective: 1000px; /* 3D 透视 */
		overflow: hidden;
	}

	/* 鼠标光晕 */
	#mouse-glow {
		position: absolute;
		top: 0;
		left: 0;
		width: 100%;
		height: 100%;
		pointer-events: none;
		z-index: 0;
		background: radial-gradient(
			800px circle at var(--mouse-x, 50%) var(--mouse-y, 50%), 
			rgba(255, 255, 255, 0.08),
			transparent 40%
		);
		mix-blend-mode: overlay;
		transition: opacity 0.5s ease;
	}

	main {
		position: relative;
		z-index: 2;
		height: 100%;
		display: flex;
		justify-content: center;
		align-items: center;
		transform-style: preserve-3d;
	}

	#hero {
		display: flex;
		align-items: center;
		flex-direction: column;
		justify-content: center;
		padding: 40px;
		padding-top: 120px; /* Avoid top bar */
		min-height: 100vh; 
		box-sizing: border-box;
		text-align: center;
		z-index: 1;
		gap: 48px;
		width: 100%;
	}

	#hero-image-wrapper {
		position: relative;
		border-radius: 24px;
		/* overflow: hidden; */ /* 移除overflow hidden以允许边框效果完整显示，但要注意内容裁剪 */
		/* box-shadow: 0 25px 50px -12px rgba(0, 0, 0, 0.5); */ /* 暂时移除阴影，由GSAP控制 */
		display: flex;
		justify-content: center;
		align-items: center;
		width: auto;
		max-width: 90%; /* 更大 */
		height: auto;
		background: rgba(255, 255, 255, 0.0); /* 初始透明 */
		/* backdrop-filter: blur(10px); */ /* 稍后动画加入 */
	}

	#hero-img-element {
		display: block;
		width: auto;
		height: auto;
		max-width: 100%;
		max-height: 70vh; /* 更大 */
		user-select: none;
		pointer-events: none;
		border-radius: 24px;
		opacity: 0; /* 初始隐藏 */
	}

	#hero-border-svg {
		position: absolute;
		top: 0;
		left: 0;
		width: 100%;
		height: 100%;
		z-index: 10;
		pointer-events: none;
		overflow: visible;
	}

	#hero-border-rect {
		fill: none;
		stroke: #000000;
		stroke-width: 2;
		vector-effect: non-scaling-stroke;
		/* Stroke dasharray set by JS */
	}

	#nano-canvas {
		position: absolute;
		top: 0;
		left: 0;
		width: 100%;
		height: 100%;
		z-index: 5;
		pointer-events: none;
		border-radius: 24px;
	}

	#links {
		display: flex;
		gap: 16px;
		justify-content: center;
		transform: translateZ(60px); /* 按钮悬浮得更高 */
		opacity: 0; /* 初始隐藏，等动画结束后显示 */
	}


	#links {
		display: flex;
		gap: 16px;
		justify-content: center;
		transform: translateZ(60px); /* 按钮悬浮得更高 */
	}

	/* 高级按钮样式 */
	.glass-button {
		position: relative;
		color: #1a1a1a;
		background: rgba(254, 221, 88, 0.9);
		border-radius: 12px;
		padding: 16px 32px;
		text-decoration: none;
		font-size: 18px;
		font-weight: 700;
		overflow: hidden;
		transition: all 0.4s cubic-bezier(0.23, 1, 0.32, 1);
		border: 1px solid rgba(255, 255, 255, 0.2);
		box-shadow: 
			0 10px 20px rgba(0, 0, 0, 0.1),
			0 6px 6px rgba(0, 0, 0, 0.1),
			inset 0 -2px 5px rgba(0,0,0,0.1),
			inset 0 2px 5px rgba(255,255,255,0.5);
	}

	.button-content {
		position: relative;
		z-index: 2;
	}

	.button-glow {
		position: absolute;
		top: -50%;
		left: -50%;
		width: 200%;
		height: 200%;
		background: radial-gradient(circle, rgba(255,255,255,0.8) 0%, transparent 60%);
		opacity: 0;
		transform: scale(0.5);
		transition: transform 0.6s ease, opacity 0.6s ease;
		z-index: 1;
		pointer-events: none;
	}

	.glass-button:hover {
		transform: translateY(-4px) scale(1.02);
		background: #fedd58;
		box-shadow: 
			0 20px 40px rgba(254, 221, 88, 0.3),
			0 10px 10px rgba(0, 0, 0, 0.1);
	}

	.glass-button:hover .button-glow {
		opacity: 0.3;
		transform: scale(1);
	}

	.glass-button:active {
		transform: translateY(-1px) scale(0.98);
	}

	/* 适配移动端 */
	@media screen and (max-width: 768px) {
		#hero {
			padding: 20px;
			gap: 20px;
			background: none;
			border: none;
			box-shadow: none;
		}

		#hero-text {
			font-size: 42px;
			transform: none;
		}
		
		#links {
			transform: none;
		}

		.glass-button {
			padding: 14px 28px;
			font-size: 16px;
		}
	}

	pre {
		font-family:
			ui-monospace, 'Cascadia Code', 'Source Code Pro', Menlo, Consolas, 'DejaVu Sans Mono',
			monospace;
		font-weight: normal;
		background: linear-gradient(14deg, #d83333 0%, #f041ff 100%);
		-webkit-background-clip: text;
		-webkit-text-fill-color: transparent;
		background-clip: text;
		margin: 0;
	}

	h2 {
		margin: 0 0 1em;
		font-weight: normal;
		color: var(--color-text-primary);
		font-size: 20px;
		transition: color 0.3s ease;
	}

	p {
		color: var(--color-text-secondary);
		font-size: 16px;
		line-height: 24px;
		letter-spacing: -0.006em;
		margin: 0;
		transition: color 0.3s ease;
	}

	code {
		display: inline-block;
		background:
			linear-gradient(66.77deg, #f3cddd 0%, #f5cee7 100%) padding-box,
			linear-gradient(155deg, #d83333 0%, #f041ff 18%, #f5cee7 45%) border-box;
		border-radius: 8px;
		border: 1px solid transparent;
		padding: 6px 8px;
	}

	:global(.dark) code {
		background:
			linear-gradient(66.77deg, #4a1942 0%, #5a2a52 100%) padding-box,
			linear-gradient(155deg, #d83333 0%, #f041ff 18%, #5a2a52 45%) border-box;
	}

	.box {
		padding: 16px;
		background: rgba(255, 255, 255, 1);
		border-radius: 16px;
		border: 1px solid white;
		transition: background 0.3s ease, border-color 0.3s ease;
	}

	:global(.dark) .box {
		background: rgba(30, 41, 59, 0.8);
		border-color: rgba(255, 255, 255, 0.1);
	}

	#news {
		position: absolute;
		bottom: 16px;
		right: 16px;
		max-width: 300px;
		text-decoration: none;
		transition: background 0.2s;
		backdrop-filter: blur(50px);
	}

	#news:hover {
		background: rgba(255, 255, 255, 0.55);
	}

	:global(.dark) #news:hover {
		background: rgba(30, 41, 59, 0.55);
	}

	@media screen and (max-height: 368px) {
		#news {
			display: none;
		}
	}

	#recent-activities {
		padding: 40px 20px;
		text-align: center;
		background: rgba(255, 255, 255, 0.1);
		backdrop-filter: blur(10px);
		margin-top: 20px;
	}

	#recent-activities h2 {
		color: white;
		font-size: 32px;
		margin-bottom: 20px;
		text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.7);
		font-family: 'ZiKuJiangHuGuFengTi', Inter, Roboto, 'Helvetica Neue', 'Arial Nova', 'Nimbus Sans', Arial, sans-serif;
	}

	.activity-image {
		background: rgba(255, 255, 255, 0.9);
		border-radius: 16px;
		padding: 16px;
		display: inline-block;
		box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
	}

	.activity-image img {
		width: 300px;
		height: auto;
		border-radius: 8px;
	}

	@media screen and (max-width: 768px) {
		#hero {
			gap: 16px;
		}

		#hero-text {
			font-size: 24px;
			margin: 0;
		}

		#links a.button {
			padding: 12px 20px;
			font-size: 16px;
		}

		.activity-image img {
			width: 250px;
		}
	}
</style>

<script>
	import { gsap } from "gsap";
	import { ScrollTrigger } from "gsap/ScrollTrigger";

	gsap.registerPlugin(ScrollTrigger);

	// Mouse Glow Effect & Parallax
	let hero: HTMLElement | null = null;
	let container: HTMLElement | null = null;
	let mouseGlow: HTMLElement | null = null;

	function initElements() {
		hero = document.getElementById('hero');
		container = document.getElementById('container');
		mouseGlow = document.getElementById('mouse-glow');
	}

	function handleMouseMove(e: MouseEvent) {
		if (!hero || !container) initElements();
		if (!hero || !container) return;

		const { clientX, clientY } = e;

		// Mouse Glow Position
		if (mouseGlow) {
			mouseGlow.style.setProperty('--mouse-x', `${clientX}px`);
			mouseGlow.style.setProperty('--mouse-y', `${clientY}px`);
		}
	}

	// Parallax removed in favor of particle scroll animation
	/*
	function handleParallaxScroll() {
		// ...
	}
	*/

	let isDarkTheme = false;

	function checkTheme() {
		isDarkTheme = document.documentElement.classList.contains('dark');
	}

	function observeThemeChange() {
		checkTheme(); // Initial check
		const observer = new MutationObserver(() => {
			checkTheme();
		});
		observer.observe(document.documentElement, {
			attributes: true,
			attributeFilter: ['class']
		});
	}

	// Intro Animation
	let particles: any[] = [];
	let canvasContext: CanvasRenderingContext2D | null = null;
	let canvasWidth = 0;
	let canvasHeight = 0;
	let introComplete = false;
	let animationFrameId: number | null = null;

	let introTimeline: gsap.core.Timeline | null = null;
	let scrollTimeline: gsap.core.Timeline | null = null;

	function cleanup() {
		// Kill specific timelines
		if (introTimeline) {
			introTimeline.kill();
			introTimeline = null;
		}
		if (scrollTimeline) {
			scrollTimeline.kill();
			scrollTimeline = null;
		}
		
		// Kill Tweens on specific elements to avoid affecting other pages
		gsap.killTweensOf("#hero-border-rect");
		gsap.killTweensOf("#hero-img-element");
		gsap.killTweensOf("#nano-canvas");
		gsap.killTweensOf("#links");
		gsap.killTweensOf("#hero-image-wrapper");

		// Kill ScrollTrigger
		ScrollTrigger.getAll().forEach(st => st.kill());
		
		// Cancel animation frame
		if (animationFrameId) {
			cancelAnimationFrame(animationFrameId);
			animationFrameId = null;
		}

		// Remove event listeners
		window.removeEventListener('mousemove', handleMouseMove);

		// Reset body overflow
		document.body.style.overflow = '';
		
		// Reset state
		particles = [];
		introComplete = false;
	}

	function initIntroAnimation() {
		const img = document.getElementById('hero-img-element') as HTMLImageElement;
		const rect = document.getElementById('hero-border-rect') as unknown as SVGRectElement;
		const canvas = document.getElementById('nano-canvas') as HTMLCanvasElement;
		const wrapper = document.getElementById('hero-image-wrapper');
		
		// Critical: Check if elements exist
		if (!img || !rect || !canvas || !wrapper) return;

		// Re-bind listeners
		window.addEventListener('mousemove', handleMouseMove, { passive: true });

		// Reset canvas visibility for intro
		canvas.style.opacity = '1'; 
		canvas.style.visibility = 'visible';
		gsap.set(canvas, { autoAlpha: 1 });

		// Block scroll initially
		document.body.style.overflow = 'hidden';

		// Ensure image is loaded to get correct dimensions for wrapper
		if (img.complete) {
			runSequence();
		} else {
			img.onload = runSequence;
		}

		function runSequence() {
			// 1. Prepare Border
			const totalLength = rect.getTotalLength();
			const perimeter = totalLength || (wrapper!.clientWidth + wrapper!.clientHeight) * 2;
			
			gsap.set(rect, {
				strokeDasharray: perimeter,
				strokeDashoffset: perimeter
			});

			// 2. Prepare Canvas
			const w = wrapper!.clientWidth;
			const h = wrapper!.clientHeight;
			canvasWidth = w;
			canvasHeight = h;
			
			const dpr = window.devicePixelRatio || 1;
			canvas.width = w * dpr;
			canvas.height = h * dpr;
			canvas.style.width = `${w}px`;
			canvas.style.height = `${h}px`;
			
			const ctx = canvas.getContext('2d');
			if (ctx) ctx.scale(dpr, dpr);
			canvasContext = ctx;
			
			// 3. Animation Timeline
			introTimeline = gsap.timeline({ 
				defaults: { ease: "power2.inOut" },
				onComplete: () => {
					introComplete = true;
					if (animationFrameId) {
						cancelAnimationFrame(animationFrameId);
						animationFrameId = null;
					}
					// 强制清空一次 Canvas，防止任何残留
					if (canvasContext) canvasContext.clearRect(0, 0, canvasWidth, canvasHeight);
					
					document.body.style.overflow = ''; // Unblock scroll
					initScrollAnimation(); // Start listening for scroll after intro
				}
			});

			// Step 1: Draw Border (Clockwise) - Faster
			introTimeline.to(rect, {
				strokeDashoffset: 0,
				duration: 1.5,
				ease: "power3.inOut"
			});

			// Step 2: Nano Particle Generate
			introTimeline.addLabel("particlesStart", "-=0.2");
			introTimeline.call(() => {
				if (!ctx) return;
				
				// Create offscreen canvas for sampling
				const offCanvas = document.createElement('canvas');
				offCanvas.width = w;
				offCanvas.height = h;
				const offCtx = offCanvas.getContext('2d');
				if (!offCtx) return;
				
				// Draw image to offscreen canvas
				offCtx.drawImage(img, 0, 0, w, h);
				
				let imgData: ImageData | null = null;
				try {
					imgData = offCtx.getImageData(0, 0, w, h);
				} catch (e) {
					console.warn("Cannot sample image data", e);
				}

				// Particle System Setup
				particles = []; // Clear existing
				const step = 4; // Density
				
				for (let y = 0; y < h; y += step) {
					for (let x = 0; x < w; x += step) {
						let r=0, g=0, b=0, a=0;
						if (imgData) {
							const index = (y * w + x) * 4;
							r = imgData.data[index];
							g = imgData.data[index + 1];
							b = imgData.data[index + 2];
							a = imgData.data[index + 3] / 255;
						} else {
							r=0; g=0; b=0; a=1;
						}
						
						if (a < 0.1) continue;
						
						const dist = (x + (h - y)) / (w + h);
						const noise = (Math.random() - 0.5) * 0.3; 
						let spawnTime = dist + noise;
						if (spawnTime < 0) spawnTime = 0;
						
						particles.push({
							x, y, r, g, b, a,
							spawnTime,
							size: Math.random() < 0.3 ? step : step - 1,
							origX: x, origY: y, // Store original position for scroll anim
							origR: r, origG: g, origB: b
						});
					}
				}
				
				// Floaters
				const floatersCount = 2000;
				for (let i=0; i<floatersCount; i++) {
					const x = Math.random() * w;
					const y = Math.random() * h;
					const dist = (x + (h - y)) / (w + h);
					particles.push({
						x, y, r: 0, g: 0, b: 0, a: 0.5,
						spawnTime: dist + (Math.random() - 0.5) * 0.2,
						size: 1,
						origX: x, origY: y,
						origR: 0, origG: 0, origB: 0,
						isFloater: true
					});
				}

				let frame = 0;
				const totalFrames = 100; // Faster (was 240)
				
				function render() {
					if (!ctx || introComplete) return; // Stop if intro complete or interrupted
					ctx.clearRect(0, 0, w, h);
					
					const progress = frame / totalFrames;
					
					for (let i = 0; i < particles.length; i++) {
						const p = particles[i];
						
						if (progress > p.spawnTime) {
							let alpha = p.a;
							const age = progress - p.spawnTime;
							if (age < 0.1) alpha *= (age / 0.1);
							
							if (p.isFloater) {
								if (age > 0.2) alpha *= (1 - (age - 0.2) * 5);
								if (alpha <= 0) continue;
							}
							
							ctx.fillStyle = `rgba(${p.r}, ${p.g}, ${p.b}, ${alpha})`;
							ctx.fillRect(p.x, p.y, p.size, p.size);
						}
					}
					
					if (progress <= 1.5) {
						frame++;
						animationFrameId = requestAnimationFrame(render);
					} else {
						// Don't clear! Keep them for scroll animation
					}
				}
				render();
			}, undefined, "-=0.5");

			// Step 3: Reveal Image - Faster
			introTimeline.to(img, {
				opacity: 1,
				duration: 1,
				ease: "power2.inOut"
			}, "particlesStart+=1.5");

			// Step 4: Show Links - Faster
			introTimeline.to("#links", {
				opacity: 1,
				duration: 0.5,
				y: 0
			}, "-=0.5");
		}
	}

	function initScrollAnimation() {
		const wrapper = document.getElementById('welcome-wrapper');
		const heroWrapper = document.getElementById('hero-image-wrapper');
		const img = document.getElementById('hero-img-element');
		const canvas = document.getElementById('nano-canvas');
		const links = document.getElementById('links');
		const heroBorder = document.getElementById('hero-border-svg');

		if (!wrapper || !heroWrapper || !img || !canvas || !particles.length || !canvasContext) return;

		// 确保 canvas 可见
		canvas.style.opacity = '1';

		scrollTimeline = gsap.timeline({
			scrollTrigger: {
				trigger: wrapper,
				start: "top top",
				end: "+=1500", // 滚动距离
				pin: true,
				scrub: 0.5, // 增加一点平滑度
				onLeave: () => {
					// 动画结束，此时应该是全屏 #f8f9fa 粒子
				}
			}
		});

		const scrollTl = scrollTimeline; // Alias for easier copy-paste logic

		// 0. 隐藏边框和按钮
		scrollTl.to([links, heroBorder], { opacity: 0, duration: 0.1 }, 0);

		// 1. 容器放大铺满屏幕
		// 计算需要的 scale 比例。假设 90% 宽，放大到 100% 宽还不够，要覆盖圆角和边距。
		// 简单起见，放大到 3-4 倍通常足够覆盖（视口比例差异）。
		scrollTl.to(heroWrapper, {
			scale: 5, 
			borderRadius: 0,
			ease: "power1.inOut",
			duration: 1
		}, 0);

		// 2. 图片淡出，只剩粒子
		scrollTl.to(img, { opacity: 0, duration: 0.2 }, 0);

		// 3. 粒子动画：放大并变色为 RecentActivities 背景色 (#f8f9fa)
		const animObj = { progress: 0 };
		
		scrollTl.to(animObj, {
			progress: 1,
			duration: 1,
			onUpdate: () => {
				renderScrollFrame(animObj.progress);
			}
		}, 0);
	}

	function renderScrollFrame(progress: number) {
		if (!canvasContext) return;
		const ctx = canvasContext;
		const w = canvasWidth;
		const h = canvasHeight;
		
		ctx.clearRect(0, 0, w, h);

		const centerX = w / 2;
		const centerY = h / 2;
		
		// 变焦效果：粒子向外扩散
		// 配合容器的 scale，粒子自身的扩散可以稍微小一点，或者为了视觉冲击力更大一点
		// 这里的 zoom 是相对于 canvas 内部坐标的
		const zoom = 1 + progress * 2; 
		
		// 颜色目标：根据主题动态变化
		// Light: #f8f9fa (248, 249, 250)
		// Dark: #0f172a (15, 23, 42)
		const targetR = isDarkTheme ? 15 : 248;
		const targetG = isDarkTheme ? 23 : 249;
		const targetB = isDarkTheme ? 42 : 250;
		
		for (let i = 0; i < particles.length; i++) {
			const p = particles[i];
			
			// 计算扩散后的位置
			let x = (p.origX - centerX) * zoom + centerX;
			let y = (p.origY - centerY) * zoom + centerY;
			
			// 颜色插值
			// 从原始颜色 -> 目标颜色
			const r = p.origR + (targetR - p.origR) * progress;
			const g = p.origG + (targetG - p.origG) * progress;
			const b = p.origB + (targetB - p.origB) * progress;
			
			// 粒子大小随进度增加，为了填满屏幕
			// 初始大小 p.size (约 3-4px)
			// 结束时需要很大才能填满空隙（因为粒子间距也在变大）
			// 容器也在放大 scale=5，所以粒子视觉大小是 (size * scale)
			// 为了融合，粒子最好变得有些模糊或巨大
			const size = p.size * (1 + progress * 10); 
			
			// Alpha 保持或微调
			let a = p.a;
			// 接近结束时，让粒子不透明，以便形成实心背景
			if (progress > 0.8) {
				a = Math.min(1, a + (progress - 0.8) * 5);
			}
			
			ctx.fillStyle = `rgba(${Math.floor(r)}, ${Math.floor(g)}, ${Math.floor(b)}, ${a})`;
			ctx.fillRect(x, y, size, size);
		}
	}

	// Start logic
	function start() {
		// Double check if we are in a valid state to start
		const isHome = document.getElementById('welcome-wrapper');
		if (!isHome) return;

		initElements();
		initIntroAnimation();
		observeThemeChange();
	}

	// Handle SPA transitions
	document.addEventListener('astro:page-load', () => {
		const isHome = document.getElementById('welcome-wrapper');
		if (isHome) {
			// We are on the home page: start animation
			cleanup(); // Reset state before starting new animation cycle
			requestAnimationFrame(start);
		} else {
			// We are NOT on the home page: clean up resources
			cleanup();
		}
	});

	// Cleanup before swapping to ensure no artifacts remain
	document.addEventListener('astro:before-swap', cleanup);
</script>
