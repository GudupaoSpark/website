---
import { getTranslator } from '@gudupao/astro-i18n';
import logo from '../assets/home/logo.png';
import background from '../assets/home/background.png';
import heroImage from '../assets/home/hero.png';
const lang = Astro.params.lang || 'en';
const t = getTranslator(lang);
---

<div id="welcome-wrapper">
	<div id="container">
		<img id="background-image" src={background.src} alt="" draggable="false" />
		<!-- 鼠标光晕层 -->
		<div id="mouse-glow"></div>
		<main>
			<section id="hero">
				<div id="hero-image-wrapper">
					<svg id="hero-border-svg" width="100%" height="100%">
						<rect id="hero-border-rect" x="0" y="0" width="100%" height="100%" rx="24" ry="24"></rect>
					</svg>
					<canvas id="nano-canvas"></canvas>
					<img id="hero-img-element" src={heroImage.src} alt="Hero" draggable="false" crossorigin="anonymous" />
				</div>
				<section id="links">
					<a class="button glass-button" href={`/${lang || 'en'}/explore`}>
						<span class="button-content">{t('welcome.explore')}</span>
						<div class="button-glow"></div>
					</a>
				</section>
			</section>
		</main>
	</div>
</div>

<style>
	#welcome-wrapper {
		position: relative;
		height: 100vh;
		overflow: hidden;
		background: #000;
	}

	#background-image {
		position: fixed;
		top: 0;
		left: 0;
		width: 100%;
		height: 100vh;
		object-fit: cover;
		z-index: -1;
		user-select: none;
		pointer-events: none;
	}

	#container {
		font-family: Inter, Roboto, 'Helvetica Neue', 'Arial Nova', 'Nimbus Sans', Arial, sans-serif;
		height: 100vh;
		position: fixed;
		top: 0;
		left: 0;
		width: 100%;
		perspective: 1000px; /* 3D 透视 */
		overflow: hidden;
	}

	/* 鼠标光晕 */
	#mouse-glow {
		position: absolute;
		top: 0;
		left: 0;
		width: 100%;
		height: 100%;
		pointer-events: none;
		z-index: 0;
		background: radial-gradient(
			800px circle at var(--mouse-x, 50%) var(--mouse-y, 50%), 
			rgba(255, 255, 255, 0.08),
			transparent 40%
		);
		mix-blend-mode: overlay;
		transition: opacity 0.5s ease;
	}

	main {
		position: relative;
		z-index: 2;
		height: 100%;
		display: flex;
		justify-content: center;
		align-items: center;
		transform-style: preserve-3d;
	}

	#hero {
		display: flex;
		align-items: center;
		flex-direction: column;
		justify-content: center;
		padding: 40px;
		padding-top: 120px; /* Avoid top bar */
		min-height: 100vh; 
		box-sizing: border-box;
		text-align: center;
		z-index: 1;
		gap: 48px;
		width: 100%;
	}

	#hero-image-wrapper {
		position: relative;
		border-radius: 24px;
		/* overflow: hidden; */ /* 移除overflow hidden以允许边框效果完整显示，但要注意内容裁剪 */
		/* box-shadow: 0 25px 50px -12px rgba(0, 0, 0, 0.5); */ /* 暂时移除阴影，由GSAP控制 */
		display: flex;
		justify-content: center;
		align-items: center;
		width: auto;
		max-width: 90%; /* 更大 */
		height: auto;
		background: rgba(255, 255, 255, 0.0); /* 初始透明 */
		/* backdrop-filter: blur(10px); */ /* 稍后动画加入 */
	}

	#hero-img-element {
		display: block;
		width: auto;
		height: auto;
		max-width: 100%;
		max-height: 70vh; /* 更大 */
		user-select: none;
		pointer-events: none;
		border-radius: 24px;
		opacity: 0; /* 初始隐藏 */
	}

	#hero-border-svg {
		position: absolute;
		top: 0;
		left: 0;
		width: 100%;
		height: 100%;
		z-index: 10;
		pointer-events: none;
		overflow: visible;
	}

	#hero-border-rect {
		fill: none;
		stroke: #000000;
		stroke-width: 2;
		vector-effect: non-scaling-stroke;
		/* Stroke dasharray set by JS */
	}

	#nano-canvas {
		position: absolute;
		top: 0;
		left: 0;
		width: 100%;
		height: 100%;
		z-index: 5;
		pointer-events: none;
		border-radius: 24px;
	}

	#links {
		display: flex;
		gap: 16px;
		justify-content: center;
		transform: translateZ(60px); /* 按钮悬浮得更高 */
		opacity: 0; /* 初始隐藏，等动画结束后显示 */
	}


	#links {
		display: flex;
		gap: 16px;
		justify-content: center;
		transform: translateZ(60px); /* 按钮悬浮得更高 */
	}

	/* 高级按钮样式 */
	.glass-button {
		position: relative;
		color: #1a1a1a;
		background: rgba(254, 221, 88, 0.9);
		border-radius: 12px;
		padding: 16px 32px;
		text-decoration: none;
		font-size: 18px;
		font-weight: 700;
		overflow: hidden;
		transition: all 0.4s cubic-bezier(0.23, 1, 0.32, 1);
		border: 1px solid rgba(255, 255, 255, 0.2);
		box-shadow: 
			0 10px 20px rgba(0, 0, 0, 0.1),
			0 6px 6px rgba(0, 0, 0, 0.1),
			inset 0 -2px 5px rgba(0,0,0,0.1),
			inset 0 2px 5px rgba(255,255,255,0.5);
	}

	.button-content {
		position: relative;
		z-index: 2;
	}

	.button-glow {
		position: absolute;
		top: -50%;
		left: -50%;
		width: 200%;
		height: 200%;
		background: radial-gradient(circle, rgba(255,255,255,0.8) 0%, transparent 60%);
		opacity: 0;
		transform: scale(0.5);
		transition: transform 0.6s ease, opacity 0.6s ease;
		z-index: 1;
		pointer-events: none;
	}

	.glass-button:hover {
		transform: translateY(-4px) scale(1.02);
		background: #fedd58;
		box-shadow: 
			0 20px 40px rgba(254, 221, 88, 0.3),
			0 10px 10px rgba(0, 0, 0, 0.1);
	}

	.glass-button:hover .button-glow {
		opacity: 0.3;
		transform: scale(1);
	}

	.glass-button:active {
		transform: translateY(-1px) scale(0.98);
	}

	/* 适配移动端 */
	@media screen and (max-width: 768px) {
		#hero {
			padding: 20px;
			gap: 20px;
			background: none;
			border: none;
			box-shadow: none;
		}

		#hero-text {
			font-size: 42px;
			transform: none;
		}
		
		#links {
			transform: none;
		}

		.glass-button {
			padding: 14px 28px;
			font-size: 16px;
		}
	}

	pre {
		font-family:
			ui-monospace, 'Cascadia Code', 'Source Code Pro', Menlo, Consolas, 'DejaVu Sans Mono',
			monospace;
		font-weight: normal;
		background: linear-gradient(14deg, #d83333 0%, #f041ff 100%);
		-webkit-background-clip: text;
		-webkit-text-fill-color: transparent;
		background-clip: text;
		margin: 0;
	}

	h2 {
		margin: 0 0 1em;
		font-weight: normal;
		color: var(--color-text-primary);
		font-size: 20px;
		transition: color 0.3s ease;
	}

	p {
		color: var(--color-text-secondary);
		font-size: 16px;
		line-height: 24px;
		letter-spacing: -0.006em;
		margin: 0;
		transition: color 0.3s ease;
	}

	code {
		display: inline-block;
		background:
			linear-gradient(66.77deg, #f3cddd 0%, #f5cee7 100%) padding-box,
			linear-gradient(155deg, #d83333 0%, #f041ff 18%, #f5cee7 45%) border-box;
		border-radius: 8px;
		border: 1px solid transparent;
		padding: 6px 8px;
	}

	:global(.dark) code {
		background:
			linear-gradient(66.77deg, #4a1942 0%, #5a2a52 100%) padding-box,
			linear-gradient(155deg, #d83333 0%, #f041ff 18%, #5a2a52 45%) border-box;
	}

	.box {
		padding: 16px;
		background: rgba(255, 255, 255, 1);
		border-radius: 16px;
		border: 1px solid white;
		transition: background 0.3s ease, border-color 0.3s ease;
	}

	:global(.dark) .box {
		background: rgba(30, 41, 59, 0.8);
		border-color: rgba(255, 255, 255, 0.1);
	}

	#news {
		position: absolute;
		bottom: 16px;
		right: 16px;
		max-width: 300px;
		text-decoration: none;
		transition: background 0.2s;
		backdrop-filter: blur(50px);
	}

	#news:hover {
		background: rgba(255, 255, 255, 0.55);
	}

	:global(.dark) #news:hover {
		background: rgba(30, 41, 59, 0.55);
	}

	@media screen and (max-height: 368px) {
		#news {
			display: none;
		}
	}

	#recent-activities {
		padding: 40px 20px;
		text-align: center;
		background: rgba(255, 255, 255, 0.1);
		backdrop-filter: blur(10px);
		margin-top: 20px;
	}

	#recent-activities h2 {
		color: white;
		font-size: 32px;
		margin-bottom: 20px;
		text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.7);
		font-family: 'ZiKuJiangHuGuFengTi', Inter, Roboto, 'Helvetica Neue', 'Arial Nova', 'Nimbus Sans', Arial, sans-serif;
	}

	.activity-image {
		background: rgba(255, 255, 255, 0.9);
		border-radius: 16px;
		padding: 16px;
		display: inline-block;
		box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
	}

	.activity-image img {
		width: 300px;
		height: auto;
		border-radius: 8px;
	}

	@media screen and (max-width: 768px) {
		#hero {
			gap: 16px;
		}

		#hero-text {
			font-size: 24px;
			margin: 0;
		}

		#links a.button {
			padding: 12px 20px;
			font-size: 16px;
		}

		.activity-image img {
			width: 250px;
		}
	}
</style>

<script>
	import { gsap } from "gsap";

	// Mouse Glow Effect & Parallax
	let hero: HTMLElement | null = null;
	let container: HTMLElement | null = null;
	let mouseGlow: HTMLElement | null = null;

	function initElements() {
		hero = document.getElementById('hero');
		container = document.getElementById('container');
		mouseGlow = document.getElementById('mouse-glow');
	}

	function handleMouseMove(e: MouseEvent) {
		if (!hero || !container) initElements();
		if (!hero || !container) return;

		const { clientX, clientY } = e;

		// Mouse Glow Position
		if (mouseGlow) {
			mouseGlow.style.setProperty('--mouse-x', `${clientX}px`);
			mouseGlow.style.setProperty('--mouse-y', `${clientY}px`);
		}
	}

	// 视差滚动效果 - Welcome 组件逐渐变暗
	function handleParallaxScroll() {
		const container = document.getElementById('container');
		if (!container) return;

		const scrollPosition = window.scrollY;
		const windowHeight = window.innerHeight;

		const scrollProgress = Math.min(scrollPosition / windowHeight, 1);
		const easedProgress = scrollProgress * scrollProgress;

		const isDark = document.documentElement.classList.contains('dark');

		if (isDark) {
			const darkness = easedProgress * 0.8;
			container.style.setProperty('--overlay-opacity', darkness.toString());
			(container as HTMLElement).style.setProperty('--overlay-color', `rgba(0, 0, 0, ${darkness})`);
			container.style.setProperty('--overlay-bg', `rgba(0, 0, 0, ${darkness})`);
		} else {
			const darkness = easedProgress * 0.6;
			container.style.setProperty('--overlay-opacity', darkness.toString());
			(container as HTMLElement).style.setProperty('--overlay-color', `rgba(0, 0, 0, ${darkness})`);
			container.style.setProperty('--overlay-bg', `rgba(0, 0, 0, ${darkness})`);
		}

		const brightness = 100 - (easedProgress * (isDark ? 40 : 30));
		const contrast = 100 - (easedProgress * 10);
		container.style.filter = `brightness(${brightness}%) contrast(${contrast}%)`;

		const blur = easedProgress * 2;
		container.style.backdropFilter = `blur(${blur}px)`;
	}

	function observeThemeChange() {
		const observer = new MutationObserver(() => {
			handleParallaxScroll();
		});
		observer.observe(document.documentElement, {
			attributes: true,
			attributeFilter: ['class']
		});
	}

	// Intro Animation
	function initIntroAnimation() {
		const img = document.getElementById('hero-img-element') as HTMLImageElement;
		const rect = document.getElementById('hero-border-rect') as unknown as SVGRectElement;
		const canvas = document.getElementById('nano-canvas') as HTMLCanvasElement;
		const wrapper = document.getElementById('hero-image-wrapper');
		
		if (!img || !rect || !canvas || !wrapper) return;

		// Ensure image is loaded to get correct dimensions for wrapper
		if (img.complete) {
			runSequence();
		} else {
			img.onload = runSequence;
		}

		function runSequence() {
			// 1. Prepare Border
			// Force a layout calc if needed
			const totalLength = rect.getTotalLength();
			// Fallback if totalLength is 0 (e.g. display none or detached)
			const perimeter = totalLength || (wrapper!.clientWidth + wrapper!.clientHeight) * 2;
			
			gsap.set(rect, {
				strokeDasharray: perimeter,
				strokeDashoffset: perimeter
			});

			// 2. Prepare Canvas
			const w = wrapper!.clientWidth;
			const h = wrapper!.clientHeight;
			// Increase resolution for "retina" / crisp nano look
			const dpr = window.devicePixelRatio || 1;
			canvas.width = w * dpr;
			canvas.height = h * dpr;
			canvas.style.width = `${w}px`;
			canvas.style.height = `${h}px`;
			
			const ctx = canvas.getContext('2d');
			if (ctx) ctx.scale(dpr, dpr);

			// 3. Animation Timeline
			const tl = gsap.timeline({ defaults: { ease: "power2.inOut" } });

			// Step 1: Draw Border (Clockwise)
			// SVG coords usually start top-left.
			// To make it look "clockwise" depends on how the rect path is defined.
			// <rect> usually draws: top-left -> top-right -> bottom-right -> bottom-left -> top-left.
			// That IS clockwise!
			tl.to(rect, {
				strokeDashoffset: 0,
				duration: 2.5,
				ease: "power3.inOut"
			});

			// Step 2: Nano Particle Generate with Image Color Sampling
			tl.addLabel("particlesStart", "-=0.5");
			tl.call(() => {
				if (!ctx) return;
				
				// Ensure image is loaded for sampling
				if (!img.complete) {
					// Ideally we wait, but since we are in a timeline, we assume preloading or fast local load.
					// If not ready, we might get empty pixels.
					// We can force a decode/wait? 
					// For now, let's proceed. If img not ready, we'll just see black/white particles or nothing.
				}

				// Create an offscreen canvas to sample image data
				const offCanvas = document.createElement('canvas');
				offCanvas.width = w;
				offCanvas.height = h;
				const offCtx = offCanvas.getContext('2d');
				if (!offCtx) return;
				
				// Draw image to offscreen canvas
				// Note: if the image has different aspect ratio than wrapper, we need to match the object-fit: contain logic?
				// The wrapper is flexible, the img is max-width/max-height.
				// We should draw the image exactly as it appears.
				// img.width/img.height might be different from natural dimensions.
				offCtx.drawImage(img, 0, 0, w, h);
				
				// Get pixel data
				// Warning: This might fail if image is cross-origin and not configured.
				// Local assets usually fine.
				let imgData: ImageData | null = null;
				try {
					imgData = offCtx.getImageData(0, 0, w, h);
				} catch (e) {
					console.warn("Cannot sample image data (CORS?)", e);
				}

				// Particle System
				// Denser particles for "generation" effect.
				// We use a grid approach to ensure coverage, plus some randomness.
				
				interface Particle {
					x: number;
					y: number;
					r: number;
					g: number;
					b: number;
					a: number; // original alpha
					spawnTime: number; // 0 to 1 progress when it appears
					size: number;
				}
				
				const particles: Particle[] = [];
				const density = 3; // Step size (pixels). 1 = full resolution (too slow? 1920x1080=2M particles).
				// density=2 => 500k particles. 
				// density=4 => 125k particles. 
				// density=5 => 80k particles. Good balance.
				
				// Let's use density = 4 for high density but playable frame rate.
				const step = 4; 
				
				for (let y = 0; y < h; y += step) {
					for (let x = 0; x < w; x += step) {
						// Sample color
						let r=0, g=0, b=0, a=0;
						if (imgData) {
							const index = (y * w + x) * 4;
							r = imgData.data[index];
							g = imgData.data[index + 1];
							b = imgData.data[index + 2];
							a = imgData.data[index + 3] / 255;
						} else {
							// Fallback to black particles if no data
							r=0; g=0; b=0; a=1;
						}
						
						// Skip transparent pixels significantly
						if (a < 0.1) continue;
						
						// Calculate spawn time based on "Uneven Wave from Bottom-Left"
						// Distance from bottom-left (0, h)
						// Normalized distance 0 to 1 (approx)
						const dist = (x + (h - y)) / (w + h);
						
						// Add noise for unevenness
						// We want clumps and irregularity.
						const noise = (Math.random() - 0.5) * 0.3; 
						
						let spawnTime = dist + noise;
						// Clamp
						if (spawnTime < 0) spawnTime = 0;
						
						particles.push({
							x, y, r, g, b, a,
							spawnTime,
							size: Math.random() < 0.3 ? step : step - 1 // Slight size variation
						});
					}
				}
				
				// Also add some "floater" particles that are purely decorative/energy
				const floatersCount = 2000;
				for (let i=0; i<floatersCount; i++) {
					const x = Math.random() * w;
					const y = Math.random() * h;
					const dist = (x + (h - y)) / (w + h);
					particles.push({
						x, y, r: 0, g: 0, b: 0, a: 0.5,
						spawnTime: dist + (Math.random() - 0.5) * 0.2,
						size: 1
					});
				}

				let frame = 0;
				const totalFrames = 240; // 4 seconds for slow generation
				
				function render() {
					if (!ctx) return;
					ctx.clearRect(0, 0, w, h);
					
					const progress = frame / totalFrames;
					
					// If complete, we can stop rendering canvas and let image take over?
					// Or keep canvas if it looks identical.
					// Since we sampled the image, the canvas *is* the image at low res (step=4).
					// We need to fade in the real image at the end to get full sharpness.
					
					// Draw particles
					for (let i = 0; i < particles.length; i++) {
						const p = particles[i];
						
						// Check if spawned
						if (progress > p.spawnTime) {
							// Particle is alive
							// Fade in?
							let alpha = p.a;
							
							// Initial "flash" or "growth" upon spawn
							const age = progress - p.spawnTime;
							if (age < 0.1) {
								// Growing/Fading in
								alpha *= (age / 0.1);
							}
							
							// Optional: "Energy" particles fade out, "Structure" particles stay
							if (p.size === 1 && p.r === 0) { // Floater logic (hacky check)
								// Floaters fade out after a while
								if (age > 0.2) alpha *= (1 - (age - 0.2) * 5); // fast fade
								if (alpha <= 0) continue;
							}
							
							ctx.fillStyle = `rgba(${p.r}, ${p.g}, ${p.b}, ${alpha})`;
							ctx.fillRect(p.x, p.y, p.size, p.size);
						}
					}
					
					if (progress <= 1.5) {
						frame++;
						requestAnimationFrame(render);
					} else {
						// Animation done
						ctx.clearRect(0,0,w,h); // clear canvas
					}
				}
				render();
			}, undefined, "-=0.5");

			// Step 3: Reveal Image (Sync with particle generation)
			// Instead of a hard clip-path, we rely on the particles filling in the image.
			// At the end, we cross-fade to the real image for sharpness.
			// Or we can use the same clip-path but matching the noise? Hard with CSS.
			// Let's just fade in the real image slowly starting halfway through.
			
			// Actually, the user wants "particles generated this image".
			// So the canvas *is* the generation. The real image should just appear when canvas is full.
			// But canvas is low res (step=4).
			// Let's start fading in the real image when progress is near end.
			
			tl.to(img, {
				opacity: 1,
				duration: 2,
				ease: "power2.inOut"
			}, "particlesStart+=2.5"); // Start fading in 2.5s after particles start

			// Step 4: Show Links
			tl.to("#links", {
				opacity: 1,
				duration: 1,
				y: 0
			}, "-=0.5");
		}
	}

	// 确保在DOM加载完成后执行
	if (document.readyState === 'loading') {
		document.addEventListener('DOMContentLoaded', () => {
			initElements();
			initIntroAnimation();
			window.addEventListener('scroll', handleParallaxScroll, { passive: true });
			window.addEventListener('mousemove', handleMouseMove, { passive: true });
			observeThemeChange();
			handleParallaxScroll();
		});
	} else {
		initElements();
		initIntroAnimation();
		window.addEventListener('scroll', handleParallaxScroll, { passive: true });
		window.addEventListener('mousemove', handleMouseMove, { passive: true });
		observeThemeChange();
		handleParallaxScroll();
	}
</script>
