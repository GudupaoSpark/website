---
// Performance Monitor - Track and analyze client-side routing performance
---

<script>
  // Performance monitoring for Astro Client Router
  class PerformanceMonitor {
    private navigationStart: number = 0;
    private metrics: Map<string, number[]> = new Map();

    constructor() {
      this.init();
    }

    init() {
      // Monitor initial page load
      this.trackInitialLoad();

      // Monitor client-side navigation
      this.trackClientNavigation();

      // Monitor Core Web Vitals
      this.trackCoreWebVitals();

      // Log performance summary on page visibility change
      document.addEventListener('visibilitychange', () => {
        if (document.hidden) {
          this.logPerformanceSummary();
        }
      });
    }

    trackInitialLoad() {
      window.addEventListener('load', () => {
        if (performance.getEntriesByType) {
          const navigationTiming = performance.getEntriesByType('navigation')[0] as PerformanceNavigationTiming;

          if (navigationTiming) {
            const metrics = {
              'DNS Lookup': navigationTiming.domainLookupEnd - navigationTiming.domainLookupStart,
              'TCP Connection': navigationTiming.connectEnd - navigationTiming.connectStart,
              'Request Time': navigationTiming.responseStart - navigationTiming.requestStart,
              'Response Time': navigationTiming.responseEnd - navigationTiming.responseStart,
              'DOM Processing': navigationTiming.domComplete - navigationTiming.domInteractive,
              'Total Load Time': navigationTiming.loadEventEnd - navigationTiming.fetchStart,
            };

            console.group('🚀 Initial Page Load Performance');
            Object.entries(metrics).forEach(([key, value]) => {
              console.log(`${key}: ${Math.round(value)}ms`);
            });
            console.groupEnd();
          }
        }
      });
    }

    trackClientNavigation() {
      // Track navigation start
      document.addEventListener('astro:before-preparation', () => {
        this.navigationStart = performance.now();
      });

      // Track navigation end
      document.addEventListener('astro:page-load', () => {
        if (this.navigationStart > 0) {
          const duration = performance.now() - this.navigationStart;
          this.recordMetric('Client Navigation', duration);

          if (import.meta.env.DEV) {
            console.log(`⚡ Client Navigation: ${Math.round(duration)}ms`);
          }

          this.navigationStart = 0;
        }
      });

      // Track view transition duration
      document.addEventListener('astro:after-swap', () => {
        const duration = performance.now() - this.navigationStart;
        this.recordMetric('View Transition', duration);
      });
    }

    trackCoreWebVitals() {
      // Largest Contentful Paint (LCP)
      if ('PerformanceObserver' in window) {
        try {
          const lcpObserver = new PerformanceObserver((list) => {
            const entries = list.getEntries();
            const lastEntry = entries[entries.length - 1] as any;
            const lcp = lastEntry.renderTime || lastEntry.loadTime;
            this.recordMetric('LCP', lcp);

            if (import.meta.env.DEV) {
              console.log(`🎨 LCP: ${Math.round(lcp)}ms`);
            }
          });
          lcpObserver.observe({ entryTypes: ['largest-contentful-paint'] });

          // First Input Delay (FID)
          const fidObserver = new PerformanceObserver((list) => {
            const entries = list.getEntries();
            entries.forEach((entry: any) => {
              const fid = entry.processingStart - entry.startTime;
              this.recordMetric('FID', fid);

              if (import.meta.env.DEV) {
                console.log(`⌨️ FID: ${Math.round(fid)}ms`);
              }
            });
          });
          fidObserver.observe({ entryTypes: ['first-input'] });

          // Cumulative Layout Shift (CLS)
          let clsScore = 0;
          const clsObserver = new PerformanceObserver((list) => {
            list.getEntries().forEach((entry: any) => {
              if (!entry.hadRecentInput) {
                clsScore += entry.value;
                this.recordMetric('CLS', clsScore);
              }
            });

            if (import.meta.env.DEV && clsScore > 0) {
              console.log(`📐 CLS: ${clsScore.toFixed(3)}`);
            }
          });
          clsObserver.observe({ entryTypes: ['layout-shift'] });

        } catch (e) {
          // PerformanceObserver not supported
        }
      }
    }

    recordMetric(name: string, value: number) {
      if (!this.metrics.has(name)) {
        this.metrics.set(name, []);
      }
      this.metrics.get(name)?.push(value);
    }

    logPerformanceSummary() {
      if (this.metrics.size === 0) return;

      console.group('📊 Performance Summary');

      this.metrics.forEach((values, name) => {
        const avg = values.reduce((a, b) => a + b, 0) / values.length;
        const min = Math.min(...values);
        const max = Math.max(...values);

        console.log(`${name}:`, {
          count: values.length,
          avg: `${Math.round(avg)}ms`,
          min: `${Math.round(min)}ms`,
          max: `${Math.round(max)}ms`,
        });
      });

      console.groupEnd();
    }

    // Public method to get metrics
    getMetrics() {
      const summary: Record<string, any> = {};

      this.metrics.forEach((values, name) => {
        const avg = values.reduce((a, b) => a + b, 0) / values.length;
        summary[name] = {
          count: values.length,
          average: Math.round(avg),
          min: Math.round(Math.min(...values)),
          max: Math.round(Math.max(...values)),
        };
      });

      return summary;
    }
  }

  // Initialize performance monitor
  function initPerformanceMonitor() {
    // Only in development or if explicitly enabled
    const shouldMonitor = import.meta.env.DEV ||
                         localStorage.getItem('enable-performance-monitor') === 'true';

    if (shouldMonitor) {
      const monitor = new PerformanceMonitor();

      // Expose to window for debugging
      (window as any).__performanceMonitor = monitor;
    }
  }

  // Run on initial page load
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', initPerformanceMonitor);
  } else {
    initPerformanceMonitor();
  }
</script>

<style>
  /* Hide performance monitor in production */
  :root {
    --performance-monitor-display: none;
  }
</style>
